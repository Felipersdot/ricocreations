{"ast":null,"code":"import _regeneratorRuntime from \"/Users/feliperodriguez/Desktop/Git Repos/ricocreations/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/feliperodriguez/Desktop/Git Repos/ricocreations/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/feliperodriguez/Desktop/Git Repos/ricocreations/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/feliperodriguez/Desktop/Git Repos/ricocreations/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/feliperodriguez/Desktop/Git Repos/ricocreations/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport axios from 'axios';\nimport HttpStatus from 'http-status-codes';\nimport { TokenUtils } from '../utils/TokenUtils';\nimport { JsogService } from 'jsog-typescript';\nvar jsog = new JsogService();\nvar BASE_URL = '';\nvar fetch = axios.create({\n  baseURL: BASE_URL\n});\naxios.defaults.headers.get['Pragma'] = 'no-cache';\naxios.defaults.headers.get['Cache-Control'] = 'no-cache, no-store';\nfetch.interceptors.response.use(function (response) {\n  return response;\n}, function (error) {\n  var errorResponse = error.response;\n  if (Transport.isTokenExpiredError(errorResponse)) {\n    return Transport.resetTokenAndReattemptRequest(error);\n  }\n  return Promise.reject(error);\n});\nvar isAlreadyFetchingAccessToken = false;\n// This is the list of waiting requests that will retry after the token refresh complete\nvar waitingRequests = [];\nvar refreshTokenCall;\nexport var Transport = /*#__PURE__*/function () {\n  function Transport() {\n    _classCallCheck(this, Transport);\n  }\n  return _createClass(Transport, null, [{\n    key: \"get\",\n    value: function get(url, classObject) {\n      return fetch.get(url, Transport.transformResponseConfig(classObject));\n    }\n  }, {\n    key: \"post\",\n    value: function post(url, data, classObject, config) {\n      return fetch.post(url, data, Transport.transformResponseConfig(classObject, config));\n    }\n  }, {\n    key: \"postAsMultipart\",\n    value: function postAsMultipart(url, data, classObject) {\n      var config = _objectSpread(_objectSpread({}, Transport.transformResponseConfig(classObject)), {}, {\n        headers: {\n          'content-type': 'multipart/form-data'\n        }\n      });\n      return fetch.post(url, data, config);\n    }\n  }, {\n    key: \"put\",\n    value: function put(url, data, classObject) {\n      return fetch.put(url, data, Transport.transformResponseConfig(classObject));\n    }\n  }, {\n    key: \"putAsMultipart\",\n    value: function putAsMultipart(url, data, classObject) {\n      var config = _objectSpread(_objectSpread({}, Transport.transformResponseConfig(classObject)), {}, {\n        headers: {\n          'content-type': 'multipart/form-data'\n        }\n      });\n      return fetch.put(url, data, config);\n    }\n  }, {\n    key: \"patch\",\n    value: function patch(url, data, classObject) {\n      return fetch.patch(url, data, Transport.transformResponseConfig(classObject));\n    }\n  }, {\n    key: \"del\",\n    value: function del(url, classObject) {\n      return fetch.delete(url, Transport.transformResponseConfig(classObject));\n    }\n  }, {\n    key: \"setAuthToken\",\n    value: function setAuthToken(authToken, refreshTokenApi) {\n      if (authToken && authToken.access_token) {\n        fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(authToken.access_token);\n        TokenUtils.saveAuthToken(authToken);\n      } else {\n        delete fetch.defaults.headers.common.Authorization;\n        // TokenUtils.removeAuthToken();\n      }\n      if (refreshTokenApi !== undefined) {\n        refreshTokenCall = refreshTokenApi;\n      }\n    }\n  }, {\n    key: \"setJwtToken\",\n    value: function setJwtToken(jwtToken) {\n      if (jwtToken) {\n        fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(jwtToken);\n        TokenUtils.saveJwtToken(jwtToken);\n      } else {\n        delete fetch.defaults.headers.common.Authorization;\n        TokenUtils.removeJwtToken();\n      }\n    }\n  }, {\n    key: \"resetTokenAndReattemptRequest\",\n    value: function () {\n      var _resetTokenAndReattemptRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(error) {\n        var _this = this;\n        var errorResponse, refreshToken, retryOriginalRequest, authToken, response, newToken;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              errorResponse = error.response;\n              refreshToken = TokenUtils.getRefreshToken();\n              if (refreshToken) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", Promise.reject(error));\n            case 5:\n              retryOriginalRequest = new Promise(function (resolve) {\n                Transport.addSubscriber(function (token) {\n                  errorResponse.config.headers.Authorization = _this.createBearerAuthorization(token);\n                  resolve(axios(errorResponse.config));\n                });\n              });\n              authToken = TokenUtils.getAuthToken();\n              if (!(authToken && !isAlreadyFetchingAccessToken)) {\n                _context.next = 19;\n                break;\n              }\n              isAlreadyFetchingAccessToken = true;\n              _context.next = 11;\n              return refreshTokenCall(authToken);\n            case 11:\n              response = _context.sent;\n              if (response.data) {\n                _context.next = 15;\n                break;\n              }\n              isAlreadyFetchingAccessToken = false;\n              return _context.abrupt(\"return\", Promise.reject(error));\n            case 15:\n              newToken = response.data.access_token;\n              TokenUtils.saveRefreshToken(newToken);\n              isAlreadyFetchingAccessToken = false;\n              Transport.onAccessTokenFetched(newToken);\n            case 19:\n              return _context.abrupt(\"return\", retryOriginalRequest);\n            case 22:\n              _context.prev = 22;\n              _context.t0 = _context[\"catch\"](0);\n              return _context.abrupt(\"return\", Promise.reject(_context.t0));\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 22]]);\n      }));\n      function resetTokenAndReattemptRequest(_x) {\n        return _resetTokenAndReattemptRequest.apply(this, arguments);\n      }\n      return resetTokenAndReattemptRequest;\n    }()\n  }, {\n    key: \"isTokenExpiredError\",\n    value: function isTokenExpiredError(errorResponse) {\n      var isExpiredError = false;\n      if (errorResponse === HttpStatus.UNAUTHORIZED) {\n        isExpiredError = TokenUtils.isTokenExpired();\n      }\n      return isExpiredError;\n    }\n  }, {\n    key: \"handleResponse\",\n    value: function handleResponse(onFulfilled, onRejected) {\n      fetch.interceptors.response.use(onFulfilled, onRejected);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(object) {\n      return jsog.serialize(object);\n    }\n  }, {\n    key: \"transformData\",\n    value: function transformData(data, classObject) {\n      var result = jsog.deserialize(data, classObject);\n      if (Array.isArray(result)) {\n        return result;\n      }\n      return result;\n    }\n  }, {\n    key: \"isAxiosError\",\n    value: function isAxiosError(error) {\n      return error.isAxiosError !== undefined;\n    }\n  }, {\n    key: \"onAccessTokenFetched\",\n    value: function onAccessTokenFetched(token) {\n      waitingRequests.forEach(function (callback) {\n        return callback(token);\n      });\n      waitingRequests = [];\n    }\n  }, {\n    key: \"addSubscriber\",\n    value: function addSubscriber(callback) {\n      waitingRequests.push(callback);\n    }\n  }, {\n    key: \"transformResponseConfig\",\n    value: function transformResponseConfig(classObject, config) {\n      var requestConfig;\n      var transformResponse;\n      var transormer = axios.defaults.transformResponse;\n      if (classObject !== undefined) {\n        transformResponse = transormer.concat(function (data) {\n          return Transport.transformData(data, classObject);\n        });\n      }\n      if (classObject !== undefined && config !== undefined) {\n        requestConfig = _objectSpread(_objectSpread({}, config), {}, {\n          transformResponse: transformResponse\n        });\n      } else if (classObject !== undefined) {\n        requestConfig = {\n          transformResponse: transformResponse\n        };\n      } else if (config !== undefined) {\n        requestConfig = config;\n      }\n      return requestConfig;\n    }\n  }, {\n    key: \"createBearerAuthorization\",\n    value: function createBearerAuthorization(token) {\n      return \"Bearer \".concat(token);\n    }\n  }, {\n    key: \"getFile\",\n    value: function getFile(url) {\n      return fetch.get(url, {\n        method: 'GET',\n        responseType: 'blob'\n      });\n    }\n  }]);\n}();","map":{"version":3,"names":["axios","HttpStatus","TokenUtils","JsogService","jsog","BASE_URL","fetch","create","baseURL","defaults","headers","get","interceptors","response","use","error","errorResponse","Transport","isTokenExpiredError","resetTokenAndReattemptRequest","Promise","reject","isAlreadyFetchingAccessToken","waitingRequests","refreshTokenCall","_classCallCheck","_createClass","key","value","url","classObject","transformResponseConfig","post","data","config","postAsMultipart","_objectSpread","put","putAsMultipart","patch","del","delete","setAuthToken","authToken","refreshTokenApi","access_token","common","Authorization","createBearerAuthorization","saveAuthToken","undefined","setJwtToken","jwtToken","saveJwtToken","removeJwtToken","_resetTokenAndReattemptRequest","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","refreshToken","retryOriginalRequest","newToken","wrap","_callee$","_context","prev","next","getRefreshToken","abrupt","resolve","addSubscriber","token","getAuthToken","sent","saveRefreshToken","onAccessTokenFetched","t0","stop","_x","apply","arguments","isExpiredError","UNAUTHORIZED","isTokenExpired","handleResponse","onFulfilled","onRejected","serialize","object","transformData","result","deserialize","Array","isArray","isAxiosError","forEach","callback","push","requestConfig","transformResponse","transormer","concat","getFile","method","responseType"],"sources":["/Users/feliperodriguez/Desktop/Git Repos/ricocreations/src/api/Transport.ts"],"sourcesContent":["import axios, { AxiosError, AxiosPromise, AxiosRequestConfig, AxiosTransformer } from 'axios';\nimport HttpStatus from 'http-status-codes';\nimport { TokenUtils } from '../utils/TokenUtils';\nimport { IOmniAuthToken } from '../models/auth/IOmniAuthToken';\nimport { Class } from 'jsog-typescript/dist/support/Class';\nimport { JsogService } from 'jsog-typescript';\nimport { JsogObject } from 'jsog-typescript/dist/model/JsogObject';\n\nconst jsog = new JsogService();\n\nconst BASE_URL: string = '';\nconst fetch = axios.create({ baseURL: BASE_URL });\n\naxios.defaults.headers.get['Pragma'] = 'no-cache';\naxios.defaults.headers.get['Cache-Control'] = 'no-cache, no-store';\n\nfetch.interceptors.response.use(\n    (response) => {\n        return response;\n    },\n    (error) => {\n        const errorResponse = error.response;\n        if (Transport.isTokenExpiredError(errorResponse)) {\n            return Transport.resetTokenAndReattemptRequest(error);\n        }\n        return Promise.reject(error);\n    }\n);\n\nlet isAlreadyFetchingAccessToken = false;\n// This is the list of waiting requests that will retry after the token refresh complete\nlet waitingRequests: any[] = [];\nlet refreshTokenCall: (authToken: IOmniAuthToken) => AxiosPromise<IOmniAuthToken>;\n\nexport class Transport {\n    public static get<T = any>(url: string, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.get<T>(url, Transport.transformResponseConfig(classObject));\n    }\n\n    public static post<T = any>(\n        url: string,\n        data?: any,\n        classObject?: Class<object>,\n        config?: AxiosRequestConfig | undefined\n    ): AxiosPromise<T> {\n        return fetch.post<T>(url, data, Transport.transformResponseConfig(classObject, config));\n    }\n\n    public static postAsMultipart<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        const config = {\n            ...Transport.transformResponseConfig(classObject),\n            headers: {\n                'content-type': 'multipart/form-data'\n            }\n        };\n        return fetch.post<T>(url, data, config);\n    }\n\n    public static put<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.put<T>(url, data, Transport.transformResponseConfig(classObject));\n    }\n\n    public static putAsMultipart<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        const config = {\n            ...Transport.transformResponseConfig(classObject),\n            headers: {\n                'content-type': 'multipart/form-data'\n            }\n        };\n        return fetch.put<T>(url, data, config);\n    }\n\n    public static patch<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.patch<T>(url, data, Transport.transformResponseConfig(classObject));\n    }\n\n    public static del<T = any>(url: string, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.delete<T>(url, Transport.transformResponseConfig(classObject));\n    }\n\n    public static setAuthToken(\n        authToken: IOmniAuthToken,\n        refreshTokenApi?: (authToken: IOmniAuthToken) => AxiosPromise<IOmniAuthToken>\n    ) {\n        if (authToken && authToken.access_token) {\n            fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(authToken.access_token);\n            TokenUtils.saveAuthToken(authToken);\n        } else {\n            delete fetch.defaults.headers.common.Authorization;\n            // TokenUtils.removeAuthToken();\n        }\n\n        if (refreshTokenApi !== undefined) {\n            refreshTokenCall = refreshTokenApi;\n        }\n    }\n\n    public static setJwtToken(jwtToken: string) {\n        if (jwtToken) {\n            fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(jwtToken);\n            TokenUtils.saveJwtToken(jwtToken);\n        } else {\n            delete fetch.defaults.headers.common.Authorization;\n            TokenUtils.removeJwtToken();\n        }\n    }\n\n    public static async resetTokenAndReattemptRequest(error: any): Promise<any> {\n        try {\n            const { response: errorResponse } = error;\n            const refreshToken = TokenUtils.getRefreshToken();\n            if (!refreshToken) {\n                return Promise.reject(error);\n            }\n            const retryOriginalRequest = new Promise((resolve) => {\n                Transport.addSubscriber((token: string) => {\n                    errorResponse.config.headers.Authorization = this.createBearerAuthorization(token);\n                    resolve(axios(errorResponse.config));\n                });\n            });\n            const authToken = TokenUtils.getAuthToken();\n            if (authToken && !isAlreadyFetchingAccessToken) {\n                isAlreadyFetchingAccessToken = true;\n                const response = await refreshTokenCall(authToken);\n                if (!response.data) {\n                    isAlreadyFetchingAccessToken = false;\n                    return Promise.reject(error);\n                }\n                const newToken = response.data.access_token;\n                TokenUtils.saveRefreshToken(newToken);\n                isAlreadyFetchingAccessToken = false;\n                Transport.onAccessTokenFetched(newToken);\n            }\n            return retryOriginalRequest;\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    public static isTokenExpiredError(errorResponse: any): boolean {\n        let isExpiredError: boolean = false;\n        if (errorResponse === HttpStatus.UNAUTHORIZED) {\n            isExpiredError = TokenUtils.isTokenExpired();\n        }\n        return isExpiredError;\n    }\n\n    public static handleResponse(onFulfilled?: (error: any) => any, onRejected?: (error: any) => any) {\n        fetch.interceptors.response.use(onFulfilled, onRejected);\n    }\n\n    public static serialize<T>(object: T): JsogObject & T {\n        return jsog.serialize(object);\n    }\n\n    public static transformData(data: any, classObject: Class<object>): object {\n        const result = jsog.deserialize(data, classObject);\n        if (Array.isArray(result)) {\n            return result as object[];\n        }\n        return result as object;\n    }\n\n    public static isAxiosError(error: any): error is AxiosError {\n        return (error as AxiosError).isAxiosError !== undefined;\n    }\n\n    private static onAccessTokenFetched(token: string) {\n        waitingRequests.forEach((callback) => callback(token));\n        waitingRequests = [];\n    }\n\n    private static addSubscriber(callback: any) {\n        waitingRequests.push(callback);\n    }\n\n    private static transformResponseConfig(\n        classObject?: Class<object>,\n        config?: AxiosRequestConfig | undefined\n    ): AxiosRequestConfig | undefined {\n        let requestConfig: AxiosRequestConfig | undefined;\n        let transformResponse: AxiosTransformer | AxiosTransformer[] | undefined;\n        const transormer = axios.defaults.transformResponse as AxiosTransformer[];\n\n        if (classObject !== undefined) {\n            transformResponse = transormer.concat((data: any) => {\n                return Transport.transformData(data, classObject);\n            });\n        }\n\n        if (classObject !== undefined && config !== undefined) {\n            requestConfig = {\n                ...config,\n                transformResponse\n            };\n        } else if (classObject !== undefined) {\n            requestConfig = {\n                transformResponse\n            };\n        } else if (config !== undefined) {\n            requestConfig = config;\n        }\n\n        return requestConfig;\n    }\n\n    private static createBearerAuthorization(token: string): string {\n        return `Bearer ${token}`;\n    }\n\n    public static getFile<T = any>(url: string): AxiosPromise<T> {\n        return fetch.get<T>(url, {\n            method: 'GET',\n            responseType: 'blob'\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}