{"ast":null,"code":"import axios from'axios';import HttpStatus from'http-status-codes';import{TokenUtils}from'../utils/TokenUtils';import{JsogService}from'jsog-typescript';const jsog=new JsogService();const BASE_URL='';const fetch=axios.create({baseURL:BASE_URL});axios.defaults.headers.get['Pragma']='no-cache';axios.defaults.headers.get['Cache-Control']='no-cache, no-store';fetch.interceptors.response.use(response=>{return response;},error=>{const errorResponse=error.response;if(Transport.isTokenExpiredError(errorResponse)){return Transport.resetTokenAndReattemptRequest(error);}return Promise.reject(error);});let isAlreadyFetchingAccessToken=false;// This is the list of waiting requests that will retry after the token refresh complete\nlet waitingRequests=[];let refreshTokenCall;export class Transport{static get(url,classObject){return fetch.get(url,Transport.transformResponseConfig(classObject));}static post(url,data,classObject,config){return fetch.post(url,data,Transport.transformResponseConfig(classObject,config));}static postAsMultipart(url,data,classObject){const config={...Transport.transformResponseConfig(classObject),headers:{'content-type':'multipart/form-data'}};return fetch.post(url,data,config);}static put(url,data,classObject){return fetch.put(url,data,Transport.transformResponseConfig(classObject));}static putAsMultipart(url,data,classObject){const config={...Transport.transformResponseConfig(classObject),headers:{'content-type':'multipart/form-data'}};return fetch.put(url,data,config);}static patch(url,data,classObject){return fetch.patch(url,data,Transport.transformResponseConfig(classObject));}static del(url,classObject){return fetch.delete(url,Transport.transformResponseConfig(classObject));}static setAuthToken(authToken,refreshTokenApi){if(authToken&&authToken.access_token){fetch.defaults.headers.common.Authorization=this.createBearerAuthorization(authToken.access_token);TokenUtils.saveAuthToken(authToken);}else{delete fetch.defaults.headers.common.Authorization;// TokenUtils.removeAuthToken();\n}if(refreshTokenApi!==undefined){refreshTokenCall=refreshTokenApi;}}static setJwtToken(jwtToken){if(jwtToken){fetch.defaults.headers.common.Authorization=this.createBearerAuthorization(jwtToken);TokenUtils.saveJwtToken(jwtToken);}else{delete fetch.defaults.headers.common.Authorization;TokenUtils.removeJwtToken();}}static async resetTokenAndReattemptRequest(error){try{const{response:errorResponse}=error;const refreshToken=TokenUtils.getRefreshToken();if(!refreshToken){return Promise.reject(error);}const retryOriginalRequest=new Promise(resolve=>{Transport.addSubscriber(token=>{errorResponse.config.headers.Authorization=this.createBearerAuthorization(token);resolve(axios(errorResponse.config));});});const authToken=TokenUtils.getAuthToken();if(authToken&&!isAlreadyFetchingAccessToken){isAlreadyFetchingAccessToken=true;const response=await refreshTokenCall(authToken);if(!response.data){isAlreadyFetchingAccessToken=false;return Promise.reject(error);}const newToken=response.data.access_token;TokenUtils.saveRefreshToken(newToken);isAlreadyFetchingAccessToken=false;Transport.onAccessTokenFetched(newToken);}return retryOriginalRequest;}catch(err){return Promise.reject(err);}}static isTokenExpiredError(errorResponse){let isExpiredError=false;if(errorResponse===HttpStatus.UNAUTHORIZED){isExpiredError=TokenUtils.isTokenExpired();}return isExpiredError;}static handleResponse(onFulfilled,onRejected){fetch.interceptors.response.use(onFulfilled,onRejected);}static serialize(object){return jsog.serialize(object);}static transformData(data,classObject){const result=jsog.deserialize(data,classObject);if(Array.isArray(result)){return result;}return result;}static isAxiosError(error){return error.isAxiosError!==undefined;}static onAccessTokenFetched(token){waitingRequests.forEach(callback=>callback(token));waitingRequests=[];}static addSubscriber(callback){waitingRequests.push(callback);}static transformResponseConfig(classObject,config){let requestConfig;let transformResponse;const transormer=axios.defaults.transformResponse;if(classObject!==undefined){transformResponse=transormer.concat(data=>{return Transport.transformData(data,classObject);});}if(classObject!==undefined&&config!==undefined){requestConfig={...config,transformResponse};}else if(classObject!==undefined){requestConfig={transformResponse};}else if(config!==undefined){requestConfig=config;}return requestConfig;}static createBearerAuthorization(token){return`Bearer ${token}`;}static getFile(url){return fetch.get(url,{method:'GET',responseType:'blob'});}}","map":{"version":3,"names":["axios","HttpStatus","TokenUtils","JsogService","jsog","BASE_URL","fetch","create","baseURL","defaults","headers","get","interceptors","response","use","error","errorResponse","Transport","isTokenExpiredError","resetTokenAndReattemptRequest","Promise","reject","isAlreadyFetchingAccessToken","waitingRequests","refreshTokenCall","url","classObject","transformResponseConfig","post","data","config","postAsMultipart","put","putAsMultipart","patch","del","delete","setAuthToken","authToken","refreshTokenApi","access_token","common","Authorization","createBearerAuthorization","saveAuthToken","undefined","setJwtToken","jwtToken","saveJwtToken","removeJwtToken","refreshToken","getRefreshToken","retryOriginalRequest","resolve","addSubscriber","token","getAuthToken","newToken","saveRefreshToken","onAccessTokenFetched","err","isExpiredError","UNAUTHORIZED","isTokenExpired","handleResponse","onFulfilled","onRejected","serialize","object","transformData","result","deserialize","Array","isArray","isAxiosError","forEach","callback","push","requestConfig","transformResponse","transormer","concat","getFile","method","responseType"],"sources":["/Users/feliperodriguez/Desktop/Git Repos/ricocreations/src/api/Transport.ts"],"sourcesContent":["import axios, { AxiosError, AxiosPromise, AxiosRequestConfig, AxiosTransformer } from 'axios';\nimport HttpStatus from 'http-status-codes';\nimport { TokenUtils } from '../utils/TokenUtils';\nimport { IOmniAuthToken } from '../models/auth/IOmniAuthToken';\nimport { Class } from 'jsog-typescript/dist/support/Class';\nimport { JsogService } from 'jsog-typescript';\nimport { JsogObject } from 'jsog-typescript/dist/model/JsogObject';\n\nconst jsog = new JsogService();\n\nconst BASE_URL: string = '';\nconst fetch = axios.create({ baseURL: BASE_URL });\n\naxios.defaults.headers.get['Pragma'] = 'no-cache';\naxios.defaults.headers.get['Cache-Control'] = 'no-cache, no-store';\n\nfetch.interceptors.response.use(\n    (response) => {\n        return response;\n    },\n    (error) => {\n        const errorResponse = error.response;\n        if (Transport.isTokenExpiredError(errorResponse)) {\n            return Transport.resetTokenAndReattemptRequest(error);\n        }\n        return Promise.reject(error);\n    }\n);\n\nlet isAlreadyFetchingAccessToken = false;\n// This is the list of waiting requests that will retry after the token refresh complete\nlet waitingRequests: any[] = [];\nlet refreshTokenCall: (authToken: IOmniAuthToken) => AxiosPromise<IOmniAuthToken>;\n\nexport class Transport {\n    public static get<T = any>(url: string, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.get<T>(url, Transport.transformResponseConfig(classObject));\n    }\n\n    public static post<T = any>(\n        url: string,\n        data?: any,\n        classObject?: Class<object>,\n        config?: AxiosRequestConfig | undefined\n    ): AxiosPromise<T> {\n        return fetch.post<T>(url, data, Transport.transformResponseConfig(classObject, config));\n    }\n\n    public static postAsMultipart<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        const config = {\n            ...Transport.transformResponseConfig(classObject),\n            headers: {\n                'content-type': 'multipart/form-data'\n            }\n        };\n        return fetch.post<T>(url, data, config);\n    }\n\n    public static put<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.put<T>(url, data, Transport.transformResponseConfig(classObject));\n    }\n\n    public static putAsMultipart<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        const config = {\n            ...Transport.transformResponseConfig(classObject),\n            headers: {\n                'content-type': 'multipart/form-data'\n            }\n        };\n        return fetch.put<T>(url, data, config);\n    }\n\n    public static patch<T = any>(url: string, data?: any, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.patch<T>(url, data, Transport.transformResponseConfig(classObject));\n    }\n\n    public static del<T = any>(url: string, classObject?: Class<object>): AxiosPromise<T> {\n        return fetch.delete<T>(url, Transport.transformResponseConfig(classObject));\n    }\n\n    public static setAuthToken(\n        authToken: IOmniAuthToken,\n        refreshTokenApi?: (authToken: IOmniAuthToken) => AxiosPromise<IOmniAuthToken>\n    ) {\n        if (authToken && authToken.access_token) {\n            fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(authToken.access_token);\n            TokenUtils.saveAuthToken(authToken);\n        } else {\n            delete fetch.defaults.headers.common.Authorization;\n            // TokenUtils.removeAuthToken();\n        }\n\n        if (refreshTokenApi !== undefined) {\n            refreshTokenCall = refreshTokenApi;\n        }\n    }\n\n    public static setJwtToken(jwtToken: string) {\n        if (jwtToken) {\n            fetch.defaults.headers.common.Authorization = this.createBearerAuthorization(jwtToken);\n            TokenUtils.saveJwtToken(jwtToken);\n        } else {\n            delete fetch.defaults.headers.common.Authorization;\n            TokenUtils.removeJwtToken();\n        }\n    }\n\n    public static async resetTokenAndReattemptRequest(error: any): Promise<any> {\n        try {\n            const { response: errorResponse } = error;\n            const refreshToken = TokenUtils.getRefreshToken();\n            if (!refreshToken) {\n                return Promise.reject(error);\n            }\n            const retryOriginalRequest = new Promise((resolve) => {\n                Transport.addSubscriber((token: string) => {\n                    errorResponse.config.headers.Authorization = this.createBearerAuthorization(token);\n                    resolve(axios(errorResponse.config));\n                });\n            });\n            const authToken = TokenUtils.getAuthToken();\n            if (authToken && !isAlreadyFetchingAccessToken) {\n                isAlreadyFetchingAccessToken = true;\n                const response = await refreshTokenCall(authToken);\n                if (!response.data) {\n                    isAlreadyFetchingAccessToken = false;\n                    return Promise.reject(error);\n                }\n                const newToken = response.data.access_token;\n                TokenUtils.saveRefreshToken(newToken);\n                isAlreadyFetchingAccessToken = false;\n                Transport.onAccessTokenFetched(newToken);\n            }\n            return retryOriginalRequest;\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    public static isTokenExpiredError(errorResponse: any): boolean {\n        let isExpiredError: boolean = false;\n        if (errorResponse === HttpStatus.UNAUTHORIZED) {\n            isExpiredError = TokenUtils.isTokenExpired();\n        }\n        return isExpiredError;\n    }\n\n    public static handleResponse(onFulfilled?: (error: any) => any, onRejected?: (error: any) => any) {\n        fetch.interceptors.response.use(onFulfilled, onRejected);\n    }\n\n    public static serialize<T>(object: T): JsogObject & T {\n        return jsog.serialize(object);\n    }\n\n    public static transformData(data: any, classObject: Class<object>): object {\n        const result = jsog.deserialize(data, classObject);\n        if (Array.isArray(result)) {\n            return result as object[];\n        }\n        return result as object;\n    }\n\n    public static isAxiosError(error: any): error is AxiosError {\n        return (error as AxiosError).isAxiosError !== undefined;\n    }\n\n    private static onAccessTokenFetched(token: string) {\n        waitingRequests.forEach((callback) => callback(token));\n        waitingRequests = [];\n    }\n\n    private static addSubscriber(callback: any) {\n        waitingRequests.push(callback);\n    }\n\n    private static transformResponseConfig(\n        classObject?: Class<object>,\n        config?: AxiosRequestConfig | undefined\n    ): AxiosRequestConfig | undefined {\n        let requestConfig: AxiosRequestConfig | undefined;\n        let transformResponse: AxiosTransformer | AxiosTransformer[] | undefined;\n        const transormer = axios.defaults.transformResponse as AxiosTransformer[];\n\n        if (classObject !== undefined) {\n            transformResponse = transormer.concat((data: any) => {\n                return Transport.transformData(data, classObject);\n            });\n        }\n\n        if (classObject !== undefined && config !== undefined) {\n            requestConfig = {\n                ...config,\n                transformResponse\n            };\n        } else if (classObject !== undefined) {\n            requestConfig = {\n                transformResponse\n            };\n        } else if (config !== undefined) {\n            requestConfig = config;\n        }\n\n        return requestConfig;\n    }\n\n    private static createBearerAuthorization(token: string): string {\n        return `Bearer ${token}`;\n    }\n\n    public static getFile<T = any>(url: string): AxiosPromise<T> {\n        return fetch.get<T>(url, {\n            method: 'GET',\n            responseType: 'blob'\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}